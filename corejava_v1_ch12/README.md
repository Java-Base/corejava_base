# 泛型程序设计

## NO.1 What?

	泛型是语言的一种特性，也是一种程序设计手段。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明

## NO.2 Why?

* 复用性：意味着编写的代码可以被很多不同类型的对象所重用。

* 可读性：使用类型参数（type parameters）使代码的可读性更高。

* 安全性：可以在编译阶段避免一些类型转换错误。

## NO.3 How?

##### 泛型类
	
* 一个泛型类(generic class)就是具有一个或多个类型变量(type parameter)的类。
	
		e.g.: class Pair<T> {}
	
##### 泛型方法
	
* 类型变量放在修饰符的后面，返回类型的前面。

* 泛型方法可以定义在普通类中，也可以定义在泛型类中。

* 当调用一额泛型方法时，在方法名钱的尖括号中放入具体的类型。
	
		e.g.: public static <T> T getMiddle(T[] a) {}

##### 类型变量的限定

* 有时，类或方法需要对类型变量加以约束。可以通过对类型变量设置限定(bound)实现这一点。
	
		e.g.: public static <T extends Comparable> T min(T[] a) {...}
		
  表示T应该是绑定类型的字类型(subtype), T和绑定类型可以是类，也可以是接口，选择extends关键字的原因是更接近字类的概念。
	
* 一个类型变量或通配符可以有多个限定
	
		e.g.: T extends Comparable & Serializable
		
  限定类型用“&”分隔，而逗号用来分隔类型变量。
	
  限定中至多有一个类，如果用一个类作为限定，它必须是限定列表中的第一个。


##### 泛型代码和虚拟机－－类型擦除

	虚拟机没有泛型类型对象－－所有对象都属于普通类。
	
	无论何时定义一个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除(ereased)类型变量，并替换为限定类型(无限定的变量用Object)。
	
* 翻译泛型表达式

	* 当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。例如，下面这个语句序列
	
			Pair<Employee> buddies = ...;
			Employee buddy = buddies.getFirst();
			
	  擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型换。
  
	  也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
			
			~ 对原始方法PairgetFirst的调用。
			~ 将返回的Object类型强制转换为Employee类型。
			
	* 当存取一个泛型域时也要插入强制类型转换

* 翻译泛型方法

		类型擦除也会出现在泛型方法中。


* 总之，需要记住有关Java泛型转换的事实:
		
	* 虚拟机中没有泛型，只有普通的类核方法。
	* 所有的类型参数都用它们的限定类型替换。
	* 桥方法被合成来保持多态。
	* 为保持类型安全性，必要时插入类型强制类型转换。

##### 约束和局限性

* 不能用基本类型实例化类型参数。

* 运行时类型查询只适用于原始类型。

* 不能抛出也不能捕获泛型类实例。

* 参数化类型的数组不合法。

* 不能实例化类型变量。

* 泛型类的静态上下文中类型变量无效。

* 注意擦除后的通知

##### 泛型类型的继承规则

	read it on the book;

##### 通配符类型

##### 反射和泛型
